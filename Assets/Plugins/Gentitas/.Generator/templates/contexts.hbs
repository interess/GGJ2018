// <auto-generated>
//     This code was generated with love by Gentitas.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using Entitas;
using System.Collections.Generic;

{{#each this}}
namespace {{@key}} {
    public partial class Contexts : IContexts {
        public static Contexts _sharedInstance {
            get {
                if(__sharedInstance == null) {
                    __sharedInstance = new Contexts();
                }

                return __sharedInstance;
            }
            set { 
                __sharedInstance = value; 
            }
        }

        static Contexts __sharedInstance;

        public static void CreateContextObserver(IContext context) {
#if(!ENTITAS_DISABLE_VISUAL_DEBUGGING && UNITY_EDITOR)
            if(UnityEngine.Application.isPlaying) {
                var observer = new Entitas.VisualDebugging.Unity.ContextObserver(context);
                UnityEngine.Object.DontDestroyOnLoad(observer.gameObject);
            }
#endif
        }

        // Contexts
        {{#each contexts}}
        {{#unless settings.isPartial}}
        {{toUpper @key}}Context _{{toLower @key}};
        public static {{toUpper @key}}Context {{toLower @key}} { get { return _sharedInstance._{{toLower @key}}; } }
        {{/unless}}

        {{/each}}

        // IndiciesValue
        {{#each contexts}}
        {{#unless settings.isPartial}}
        {{#each indicies.single}}
        public const string {{toUpper @../key}}{{toUpper @key}} = "{{toUpper @../key}}{{toUpper @key}}";
        {{/each}}
        {{#each indicies.multi}}
        public const string {{toUpper @../key}}{{toUpper @key}} = "{{toUpper @../key}}{{toUpper @key}}";
        {{/each}}
        {{/unless}}
        {{/each}}

        public IContext[] allContexts { get { return new IContext [] { {{#each contexts}}{{#unless settings.isPartial}}_{{toLower @key}}{{#unless @last}}, {{/unless}}{{/unless}}{{/each}} }; } }

        public Contexts() {
            {{#each contexts}}
            {{#unless settings.isPartial}}
            _{{toLower @key}} = new {{toUpper @key}}Context();
            {{/unless}}
            {{/each}}

            {{#each contexts}}
            {{#unless settings.isDisableObserver}}
            CreateContextObserver(_{{toLower name}});
            {{/unless}}
            {{/each}}
        }

        public static void Reset() {
            var contexts = _sharedInstance.allContexts;
            for (int i = 0; i < contexts.Length; i++) {
                contexts[i].Reset();
            }
        }

        public static void HardReset() {
            __sharedInstance = new Contexts();
        }
    }

    {{#each contexts}}
    {{#unless settings.isPartial}}
    public partial class {{toUpper @key}}Context : Context<{{toUpper @key}}Entity>{{#each settings.extendContextInterfaces}}, IContext<global::{{this}}Entity>{{/each}}  {
        public {{toUpper @key}}Context()
            : base(
                {{toUpper @key}}ComponentsLookup.TotalComponents,
                0,
                new ContextInfo(
                    "{{realNamespace}}.{{toUpper @key}}",
                    {{toUpper @key}}ComponentsLookup.componentNames,
                    {{toUpper @key}}ComponentsLookup.componentTypes
                ),
                (entity) =>

    #if (ENTITAS_FAST_AND_UNSAFE)
                    new Entitas.UnsafeAERC()
    #else
                    new Entitas.SafeAERC(entity)
    #endif

            ) 
        {
            {{#each indexes}}
            {{toLower name}}Index = new {{realNamespace}}.Indexes.{{toUpper ../name}}.{{toUpper name}}Index(this);
            {{/each}}
        }

        {{#each indexes}}
        /// Value: {{valueComponentName}} {{#if flagComponentNames}}| Flags:{{/if}} {{#each flagComponentNames}}{{toUpper this}}{{/each}}
        public {{realNamespace}}.Indexes.{{toUpper ../name}}.I{{toUpper name}}Index {{toLower name}}Index;
        {{/each}}

        {{#each indiciesValue}}
        {{#if indexUniqueValue}}
        public bool HasEntityWith{{toUpper @key}}({{fieldValue}} value) {
            var collection = ((Entitas.EntityIndex<{{../toUpper @key}}Entity, {{fieldValue}}>)GetEntityIndex(Contexts.{{contextValue.toUpper @key}}{{toUpper @key}})).GetEntities(value);
            return collection.Count == 1;
        }

        public {{../toUpper @key}}Entity GetEntityWith{{toUpper @key}}({{fieldValue}} value) {
            var collection = ((Entitas.EntityIndex<{{../toUpper @key}}Entity, {{fieldValue}}>)GetEntityIndex(Contexts.{{contextValue.toUpper @key}}{{toUpper @key}})).GetEntities(value);
            if (collection.Count == 0) return null;
            if (collection.Count == 1) return collection.SingleEntity();
            throw new System.Exception("{{../toUpper @key}}Context does not have Entity with {{toUpper @key}} = " + value + ". Try checking with HasEntityWith{{toUpper @key}}({{fieldValue}} value) before calling Get method.");
        }
        {{else}}
        public System.Collections.Generic.HashSet<{{../toUpper @key}}Entity> GetEntitiesWith{{toUpper @key}}({{fieldValue}} value) {
            return ((Entitas.EntityIndex<{{../toUpper @key}}Entity, {{fieldValue}}>)GetEntityIndex(Contexts.{{contextValue.toUpper @key}}{{toUpper @key}})).GetEntities(value);
        }
        {{/if}}

        {{/each}}
    }
    {{/unless}}

    public static class {{toUpper @key}}ComponentsLookup {
        {{#each components}}
        public const int {{toUpper @key}} = {{@index}};
        {{/each}}

        public const int TotalComponents = {{len components}};

        public static readonly Dictionary<string, int> componentsDict = new Dictionary<string, int> () {
            {{#each components}}
            {"{{toUpper @key}}", {{@index}} }{{#unless @last}},{{/unless}}
            {{/each}}
        };

        public static readonly string[] componentNames = {
            {{#each components}}
            "{{toUpper @key}}"{{#unless @last}},{{/unless}}
            {{/each}}
        };

        public static readonly System.Type[] componentTypes = {
            {{#each components}}
            typeof(Components.{{toUpper @../key}}.{{toUpper @key}}){{#unless @last}},{{/unless}}
            {{/each}}
        };

        public static int GetComponentIndex(string name) {
            int resultIndex = -1;
            if (componentsDict.TryGetValue(name, out resultIndex)) {
                return resultIndex;
            }

            return -1;
        }

        public static int GetComponentIndex(System.Type t) {
            for (var i = 0; i < componentTypes.Length; i++) {
                if (componentTypes[i] == t) return i;
            }

            return -1;
        }
    }
    {{/each}}
}
{{/each}}
